<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shakib's 3D Ball Game - Spikes & Powerups</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
      background: #111;
      color: white;
    }
    canvas { display: block; }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      transition: all 0.3s ease;
    }
    #scoreDisplay {
      font-size: 24px;
      margin-bottom: 5px;
    }
    #gameOver {
      position: absolute;
      top: 35%;
      width: 100%;
      text-align: center;
      font-size: 48px;
      color: red;
      opacity: 0;
      transition: opacity 1s ease;
      pointer-events: none;
    }
    #restartBtn {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 25px;
      font-size: 20px;
      background: #444;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 1s ease;
    }
    #restartBtn:hover {
      background: #666;
    }
    .show {
      opacity: 1 !important;
      pointer-events: all !important;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="scoreDisplay">Score: <span id="score">0</span></div>
    <div>High Score: <span id="highScore">0</span></div>
  </div>
  <div id="gameOver">Game Over!</div>
  <button id="restartBtn">Restart</button>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, ball, ground;
    let keys = {};
    let jumping = false, ducking = false;
    let jumpSpeed = 0, gravity = -0.01;
    let score = 0, gameOver = false, speedMultiplier = 1;
    let obstacles = [], spikes = [], powerups = [];
    let invincible = false;
    let powerupTimeout;

    const scoreDisplay = document.getElementById("score");
    const highScoreDisplay = document.getElementById("highScore");
    const restartBtn = document.getElementById("restartBtn");
    const gameOverText = document.getElementById("gameOver");

    const storedHighScore = localStorage.getItem("highScore") || 0;
    highScoreDisplay.innerText = storedHighScore;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 10, 10).normalize();
      scene.add(light);

      const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
      const ballMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
      ball = new THREE.Mesh(ballGeometry, ballMaterial);
      scene.add(ball);
      ball.position.set(0, 0.5, 0);

      const groundGeometry = new THREE.PlaneGeometry(20, 100);
      const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
      ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      camera.position.set(0, 5, 10);
      camera.lookAt(ball.position);

      document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
      document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

      restartBtn.addEventListener("click", () => location.reload());

      setInterval(() => {
        if (!gameOver) {
          Math.random() < 0.7 ? createObstacle() : createSpike();
          if (Math.random() < 0.1) createPowerup();
        }
      }, 1200);

      setInterval(() => {
        if (!gameOver) {
          score++;
          scoreDisplay.innerText = score;
        }
      }, 200);

      setInterval(() => {
        if (!gameOver) speedMultiplier += 0.1;
      }, 10000);
    }

    function createObstacle() {
      const isLow = Math.random() < 0.5;
      const size = isLow ? 0.5 : 2;
      const width = Math.random() * 1 + 0.5;
      const geometry = new THREE.BoxGeometry(width, size, width);
      const material = new THREE.MeshPhongMaterial({ color: isLow ? 0xffaa00 : 0xff0000 });
      const obstacle = new THREE.Mesh(geometry, material);
      obstacle.position.set((Math.random() - 0.5) * 10, size / 2, -50);
      obstacle.userData.low = isLow;
      scene.add(obstacle);
      obstacles.push(obstacle);
    }

    function createSpike() {
      const geometry = new THREE.ConeGeometry(0.5, 1, 4);
      const material = new THREE.MeshPhongMaterial({ color: 0xff00ff });
      const spike = new THREE.Mesh(geometry, material);
      spike.position.set((Math.random() - 0.5) * 10, 0.5, -50);
      scene.add(spike);
      spikes.push(spike);
    }

    function createPowerup() {
      const geometry = new THREE.SphereGeometry(0.3, 16, 16);
      const material = new THREE.MeshPhongMaterial({ color: 0x00ccff, emissive: 0x0033ff });
      const pu = new THREE.Mesh(geometry, material);
      pu.position.set((Math.random() - 0.5) * 10, 1.5, -50);
      scene.add(pu);
      powerups.push(pu);
    }

    function animate() {
      if (gameOver) return;
      requestAnimationFrame(animate);

      const speed = 0.2;
      if (keys['arrowleft']) ball.position.x -= speed;
      if (keys['arrowright']) ball.position.x += speed;
      if (keys['arrowup']) ball.position.z -= speed;
      if (keys['arrowdown']) ball.position.z += speed;

      ball.position.x = Math.max(-9, Math.min(9, ball.position.x));
      ball.position.z = Math.max(-45, Math.min(10, ball.position.z));

      if (!jumping && keys[' ']) {
        jumping = true;
        jumpSpeed = 0.2;
      }
      if (jumping) {
        ball.position.y += jumpSpeed;
        jumpSpeed += gravity;
        if (ball.position.y <= 0.5) {
          ball.position.y = 0.5;
          jumping = false;
        }
      }

      if (keys['shift']) {
        if (!ducking) {
          ducking = true;
          ball.scale.y = 0.5;
          ball.position.y = 0.25;
        }
      } else if (ducking) {
        ducking = false;
        ball.scale.y = 1;
        if (!jumping) ball.position.y = 0.5;
      }

      // Obstacles
      for (let i = 0; i < obstacles.length; i++) {
        const obs = obstacles[i];
        obs.position.z += 0.5 * speedMultiplier;

        if (checkCollision(ball, obs)) {
          if ((obs.userData.low && ball.position.y > 1) || (!obs.userData.low && ducking)) {
            continue;
          }
          if (!invincible) endGame();
        }

        if (obs.position.z > 20) {
          scene.remove(obs);
          obstacles.splice(i, 1);
          i--;
        }
      }

      // Spikes
      for (let i = 0; i < spikes.length; i++) {
        const spike = spikes[i];
        spike.position.z += 0.5 * speedMultiplier;
        if (checkCollision(ball, spike) && !invincible) {
          endGame();
        }
        if (spike.position.z > 20) {
          scene.remove(spike);
          spikes.splice(i, 1);
          i--;
        }
      }

      // Powerups
      for (let i = 0; i < powerups.length; i++) {
        const pu = powerups[i];
        pu.position.z += 0.5 * speedMultiplier;

        if (checkCollision(ball, pu)) {
          activatePowerup();
          scene.remove(pu);
          powerups.splice(i, 1);
          i--;
        }

        if (pu.position.z > 20) {
          scene.remove(pu);
          powerups.splice(i, 1);
          i--;
        }
      }

      renderer.render(scene, camera);
    }

    function checkCollision(obj1, obj2) {
      const box1 = new THREE.Box3().setFromObject(obj1);
      const box2 = new THREE.Box3().setFromObject(obj2);
      return box1.intersectsBox(box2);
    }

    function activatePowerup() {
      invincible = true;
      ball.material.emissive = new THREE.Color(0x00ffcc);
      clearTimeout(powerupTimeout);
      powerupTimeout = setTimeout(() => {
        invincible = false;
        ball.material.emissive = new THREE.Color(0x000000);
      }, 5000);
    }

    function endGame() {
      gameOver = true;
      const best = Math.max(score, parseInt(localStorage.getItem("highScore") || 0));
      localStorage.setItem("highScore", best);
      highScoreDisplay.innerText = best;
      gameOverText.classList.add("show");
      restartBtn.classList.add("show");
    }
  </script>
</body>
</html>
